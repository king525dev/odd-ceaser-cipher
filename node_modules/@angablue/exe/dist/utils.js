"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.warningSuppression = exports.execAsync = void 0;
exports.signtool = signtool;
exports.parseOptions = parseOptions;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const util_1 = require("util");
const signtoolPackagePath = require.resolve('signtool');
exports.execAsync = (0, util_1.promisify)(child_process_1.exec);
/**
 * Get the path to the signtool executable.
 * @returns The path to the signtool executable.
 */
function getSigntoolPath() {
    const signtoolPath = path_1.default.dirname(signtoolPackagePath);
    switch (process.arch) {
        case 'ia32':
            return path_1.default.join(signtoolPath, 'signtool', 'x86', 'signtool.exe').replace(/\\/g, '/');
        case 'x64':
            return path_1.default.join(signtoolPath, 'signtool', 'x64', 'signtool.exe').replace(/\\/g, '/');
        case 'arm':
        default:
            throw new Error('Signtool is not supported in this environment');
    }
}
/**
 * Sign a file using signtool.
 * @param args Arguments to pass to signtool.
 * @returns A promise that resolves when the file is signed.
 */
function signtool(args) {
    const signtoolPath = getSigntoolPath();
    return (0, exports.execAsync)(`"${signtoolPath}" ${args.join(' ')}`);
}
exports.warningSuppression = "const originalError=console.error;console.error=(msg,...args)=>{if(typeof msg==='string'&&msg.includes('Single executable application is an experimental feature and might change at any time')||msg.includes('Currently the require() provided to the main script embedded into single-executable applications only supports loading built-in modules.'))return;originalError(msg,...args);};";
/**
 * Replace package:(name|version|author) with the value from the data object.
 * Example 1: "{package:name}" will be replaced with the name from the package.json file.
 * Example 2: "{package:author.name}" will be replaced with the author.name from the package.json file.
 *
 * @param value string to parse
 * @param data object to use for replacement
 * @returns updated value
 */
function parseValue(value, data) {
    // https://regex101.com/r/AvVwrD/3
    const regex = /\{(package:(?<prop>[a-z]+)(\.(?<subprop>[a-z]+))?)\}/gi;
    const match = regex.exec(value);
    const { prop, subprop } = match?.groups || {};
    if (prop && data[prop]) {
        if (subprop && data[prop][subprop]) {
            return value.replace(regex, data[prop][subprop]);
        }
        return value.replace(regex, data[prop]);
    }
    return value;
}
/**
 * Replace package tokens in option values with their actual values from the cwd package.json file.
 * @param {Options} options
 * @returns A new options object with the tokens replaced.
 */
async function parseOptions(options) {
    const { properties, ...rest } = options;
    try {
        const packageJsonPath = path_1.default.resolve(process.cwd(), 'package.json');
        const packageJson = JSON.parse(await fs_1.promises.readFile(packageJsonPath, 'utf8'));
        const newOptions = {
            properties: {}
        };
        // eslint-disable-next-line guard-for-in
        for (const key in rest) {
            const isStr = typeof rest[key] === 'string';
            newOptions[key] = isStr ? parseValue(rest[key], packageJson) : rest[key];
        }
        // eslint-disable-next-line guard-for-in
        for (const key in properties) {
            const isStr = typeof properties[key] === 'string';
            newOptions.properties[key] = isStr ? parseValue(properties[key], packageJson) : properties[key];
        }
        return newOptions;
    }
    catch (err) {
        // If the package.json file is not found, return the original options
    }
    return options;
}
