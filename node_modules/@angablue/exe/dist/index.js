"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_1 = require("fs");
const cjs_1 = require("resedit/cjs");
const postject_1 = require("postject");
const path_1 = require("path");
const ncc_1 = __importDefault(require("@vercel/ncc"));
const utils_1 = require("./utils");
// Language code for en-us and encoding codepage for UTF-16
const language = {
    lang: 1033, // en-us
    codepage: 1200 // UTF-16
};
/**
 * Build an executable
 * @param {Options} options
 * @returns An empty promise which is resolved when the executable is built
 */
async function exe(options) {
    const opts = await (0, utils_1.parseOptions)(options);
    // Build w/ Node - Single Executable Application
    // https://nodejs.org/api/single-executable-applications.html
    // Replace backslashes with forward slashes to avoid escaping issues
    const out = opts.out.replace(/\\/g, '/');
    const bundle = `${out}.bundle.js`;
    const seaConfig = `${out}.sea-config.json`;
    const seaBlob = `${out}.blob`;
    let code = '';
    if (opts.skipBundle) {
        // Use the entry file as is
        code = await fs_1.promises.readFile((0, path_1.resolve)(opts.entry), 'utf8');
    }
    else {
        // Bundle with ncc
        const output = await (0, ncc_1.default)((0, path_1.resolve)(opts.entry), {
            minify: true,
            quiet: true,
            target: 'es2021'
        });
        code = output.code;
    }
    // Write the bundled code to a file and prepend the SEA require() warning suppression
    const pattern = /^#!.*\n/;
    const match = code.match(pattern);
    if (match) {
        // Shebang found, insert after the shebang
        code = `${match[0]}${utils_1.warningSuppression}${code.slice(match[0].length)}`;
    }
    else {
        // No shebang, prepend at the beginning
        code = `${utils_1.warningSuppression}${code}`;
    }
    await fs_1.promises.writeFile(bundle, code);
    // Write sea-config.json
    await fs_1.promises.writeFile(seaConfig, JSON.stringify({
        main: bundle,
        output: seaBlob,
        disableExperimentalSEAWarning: true
    }, null, 2));
    // Generate blob
    await (0, utils_1.execAsync)(`node --experimental-sea-config "${seaConfig}"`);
    // Generate .exe
    await fs_1.promises.copyFile(process.execPath, out);
    // Remove the signature
    await (0, utils_1.signtool)(['remove', '/s', `"${out}"`]);
    // Inject blob into .exe
    const seaBlobData = await fs_1.promises.readFile(seaBlob);
    await (0, postject_1.inject)(out, 'NODE_SEA_BLOB', Buffer.from(seaBlobData), { sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2' });
    // Remove temporary files
    await fs_1.promises.unlink(bundle);
    await fs_1.promises.unlink(seaConfig);
    await fs_1.promises.unlink(seaBlob);
    // Modify .exe w/ ResEdit
    const RE = await (0, cjs_1.load)();
    const data = await fs_1.promises.readFile(opts.out);
    const executable = RE.NtExecutable.from(data);
    const res = RE.NtExecutableResource.from(executable);
    const vi = RE.Resource.VersionInfo.fromEntries(res.entries)[0];
    // Remove original filename
    vi.removeStringValue(language, 'OriginalFilename');
    vi.removeStringValue(language, 'InternalName');
    // Product version
    if (opts.version) {
        // Convert version to tuple of 3 numbers
        const version = opts.version
            .split('.')
            .map((v) => Number(v) || 0)
            .slice(0, 3);
        // Update versions
        vi.setProductVersion(...version, 0, language.lang);
        vi.setFileVersion(...version, 0, language.lang);
    }
    // Add additional user specified properties
    if (opts.properties) {
        vi.setStringValues(language, opts.properties);
    }
    vi.outputToResourceEntries(res.entries);
    // Add icon
    if (opts.icon) {
        const iconFile = RE.Data.IconFile.from(await fs_1.promises.readFile(opts.icon));
        RE.Resource.IconGroupEntry.replaceIconsForResource(res.entries, 1, language.lang, iconFile.icons.map(item => item.data));
    }
    // Execution level
    const level = opts.executionLevel || 'asInvoker';
    const manifest = res.getResourceEntriesAsString(24, 1)[0][1];
    res.replaceResourceEntryFromString(24, 1, language.lang, manifest.replace('asInvoker', level));
    // Regenerate and write to .exe
    res.outputResource(executable);
    await fs_1.promises.writeFile(opts.out, Buffer.from(executable.generate()));
}
module.exports = exe;
